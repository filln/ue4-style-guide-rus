<a name="3.0"></a>
<a name="bp"></a>
## 3. Блупринты 

Этот раздел описывает блупринты и их внутреннее обустройство. Там, где возможно, эти правила подчиняются [стандарту кодинга Epic](https://docs.unrealengine.com/latest/INT/Programming/Development/CodingStandard).

### Подразделы

> 3.1 [Компиляция](#bp-compiling)

> 3.2 [Переменные](#bp-vars)

> 3.3 [Функции](#bp-functions)

> 3.4 [Графы](#bp-graphs)

<a name="3.1"></a>
<a name="bp-compiling"></a>
### 3.1 Компиляция 

Все блупринты должны компилиться без предупреждений и ошибок. Вы должны исправить все предупреждения и ошибки при первой возможности, т.к. они сразу могут превратиться в снежный ком проблем и вызвать непредвиденное поведение.

*Никогда не отправляйте* (submit) сломанные блупринты в систему контроля версиями. Если вам нужно хранить их в системе контроля версий, отложите их (shelve).

Сломанные блупринты могут вызвать массу проблем — таких, как поломанные связи, некорректное поведение, падения при сборке, частые ненужные перекомпиляции. Один сломанный блупринт способен порушить всю вашу игру.

<a name="3.2"></a>
<a name="bp-vars"></a>
### 3.2 Переменные

#### Подразделы

> 3.2.1 [Именование](#bp-vars)

> 3.2.2 [`Editable`](#bp-vars-editable)

> 3.2.3 [Категории](#bp-vars-categories)

> 3.2.4 [Уровни доступа](#bp-vars-access)

> 3.2.5 [`Advanced`](#bp-vars-advanced)

> 3.2.6 [`Transient`](#bp-vars-transient)

> 3.2.7 [`SaveGame`](#bp-vars-savegame)

> 3.2.8 [Переменные `Config`](#bp-vars-config)

<a name="3.2.1"></a>
<a name="bp-var-naming"></a>
#### 3.2.1 Именование 

<a name="3.2.1.1"></a>
<a name="bp-var-naming-nouns"></a>
##### 3.2.1.1 Существительные 

Все не-булевые переменные должны быть чёткими, недвусмысленными, описательными существительными.

<a name="3.2.1.2"></a>
<a name="bp-var-naming-case"></a>
##### 3.2.1.2 ДельфиСтиль 

Все не-булевые переменные должны быть написаны в [ДельфиСтиле](StyleGuide/0-ContentsAndDescription.md#terms-cases).

<a name="3.2.1.2e"></a>
###### 3.2.1.2e Примеры:

* `Score`
* `Kills`
* `TargetPlayer`
* `Range`
* `CrosshairColor`
* `AbilityID`

<a name="3.2.1.3"></a>
<a name="bp-var-bool-prefix"></a>
##### 3.2.1.3 Префикс `b` для булевых переменных 

Все булевы значения должны следовать ДельфиСтилю, но иметь префикс в виде малой `b`.

Например: `bDead` и `bEvil`, **но не** `Dead` и `Evil`.

Редактор блупринтов в UE4 распознаёт эту `b` и не выводит её при выводе удобочитаемого текста.

<a name="3.2.1.4"></a>
<a name="bp-var-bool-names"></a>
##### 3.2.1.4 Имена булевых значений 

<a name="3.2.1.4.1"></a>
###### 3.2.1.4.1 Общая информация и независимые состояния 

Все булевые переменные должны быть качественными прилагательными. Не включайте вопросительные слова, например, `Is`. Такие слова зарезервированы для функций.

Например: используйте `bDead` и `bHostile`, но **не** `bIsDead` и `bIsHostile`.

Старайтесь также не использовать в названиях глаголы (напр. `bRunning`). Глаголы, как правило, ведут к сложным состояниям.

<a name="3.2.1.4.2"></a>
###### 3.2.1.4.2 Сложные состояния 

Не используйте булевы переменные для описания сложных и/или зависимых состояний. Это приводит к затруднённому управлению этих состояний и нечитабельности. Вместо этого используйте перечисление (Enum).

Например: описывая пушку, **не используйте** `bReloading` и `bEquipping`, если пушка не может одновременно заряжаться и быть в процессе экипировки. Обозначьте перечисление `EWeaponState` и используйте вместо булевых переменных одну переменную `WeaponState` соответствующего типа. Так добавлять новые состояния пушке будет проще.

Пример: **не используйте** `bRunning` ("Бежит"), если вам также нужны `bWalking` ("Ходит") и `bSprinting` ("Спринтует", кратковременное ускорение). Вам нужно перечисление с чёткими названиями вариантов.

<a name="3.2.1.5"></a>
<a name="bp-vars-naming-context"></a>
##### 3.2.1.5 Предметная область переменной определяется самим блупринтом, но не названием 

Все названия переменных не должны быть избыточны и упоминать свой контекст, так как все переменные из блупринта уже обладают своим контекстом.

<a name="3.2.1.5e"></a>
###### 3.2.1.5e Пример:

Пусть у нас есть блупринт `BP_PlayerCharacter`.

**Нельзя**

* `PlayerScore`
* `PlayerKills`
* `MyTargetPlayer`
* `MyCharacterName`
* `CharacterSkills`
* `ChosenCharacterSkin`

Названия этих переменных избыточны. Если переменные описаны в `BP_PlayerCharacter`, то это значит, что они характеризуют именно `BP_PlayerCharacter`.

**Надо**

* `Score`
* `Kills`
* `TargetPlayer`
* `Name`
* `Skills`
* `Skin`

<a name="3.2.1.6"></a>
<a name="bp-vars-naming-atomic"></a>
##### 3.2.1.6 _Не включайте_ названия атомарных типов 

Атомарные, или примитивные, переменные — это такие переменные, что описывают своё значение в простейшей форме — напимер, в виде булевого значения, целочисленного, вещественного, перечисления (Enum).

Строки (именно String, не Text!), Rotator и векторы тоже считаются атомарными в блупринтах и тоже не должны включать названия типа в своих именах. Тем не менее, с технической точки зрения они не являются атомарными.

> Хоть вектора и состоят каждый из трёх вещественных значений, с векторами часто работают как с единым целым. То же и с Rotator.

> _Нельзя_ считать Text атомарным типом, т.к. они включают в себе скрытый функционал по локализации. Атомным типом является `String`, но не `Text`.

Атомные переменные не должны включать название типа переменной в своём названии.

Например: используйте `Score`, `Kills` и `Description`, **но не** `ScoreFloat`, `FloatKills`, `DescriptionString`.

Единственное исключение этого правила — когда имеется ввиду "количество того-то" **и** когда использование имени без типа переменной приводит к затруднению чтения.

Например: генератор забора создаёт X досок. Это X нужно сохранить в переменной `NumBoards` или `BoardsCount`, но не `Boards`, т.к. `Boards` может уже относиться к массиву переменных типа `Board`.

<a name="3.2.1.7"></a>
<a name="bp-vars-naming-complex"></a>
##### 3.2.1.7 **Нужно** включать имена неатомарных типов в названиях переменных 

Неатомартные, или сложные, переменные — это такие, что отражают свою информацию как набор атомарных переменных. Структуры, классы, интерфейсы, примитивы со скрытым поведением (вроде `Text` и `Name`) попадают под это правило.

> В то время, как массив атомарных значений — это список атомарных переменных, массивы не меняют "атомарность" типа переменных.

Эти переменные должны включать названия их типов, но также и подразумевать контекст использования.

Если класс _владеет_ экземпляром сложной переменной, напр. если у `BP_PlayerCharacter` есть `BP_Hat`, то она должна называться как тип переменной, без каких-либо изменений.

Например: используйте `BP_Hat`, `BP_Flag`, и `BP_Ability`, **но не** `MyHat`, `MyFlag`, или `PlayerAbility`.

Если класс _не владеет_ значением сложной переменной, то нужно использовать существительное вместе с названием типа переменной.

Например: если у `BP_Turret` есть способность нацеливаться на `BP_PlayerCharacter`, она (туррель) должна хранить переменную `TargetPlayer` — так в контексте `BP_Turret` будет понятно, что это ссылка на другую переменную сложного типа, которой туррель не владеет.


<a name="3.2.1.8"></a>
<a name="bp-vars-naming-arrays"></a>
##### 3.2.1.8 Массивы 

Массивы подчиняются правилам выше, но описываются во множественном числе.

Например: используйте `Targets`, `Hats` и `EnemyPlayers`, **но не** `TargetList`, `HatArray`, `EnemyPlayerArray`.


<a name="3.2.2"></a>
<a name="bp-vars-editable"></a>
#### 3.2.2 Редактируемые (`Editable`) переменные 

Все переменные, которые спокойно можно менять с целью настройки поведения блупринта, должны быть отмечены как  `Editable`.

Аналогично, все те переменные, которые небезопасно редактировать и которые не должны быть раскрыты дизайнерам, не должны быть отмечены как `Editable`, за исключением тех случаев, когда переменная требует флага `Expose On Spawn`.

Не помечайте переменные флагом `Editable` произвольным образом.

<a name="3.2.2.1"></a>
<a name="bp-vars-editable-tooltips"></a>
##### 3.2.2.1 Подсказки 

Все переменные типа `Editable`, включая те, что были помечены так только из-за флага `Expose On Spawn`, должны иметь своё описание в поле `Tooltip`, которое должно показывать, как изменение этого значения меняет поведение блупринта.

<a name="3.2.2.2"></a>
<a name="bp-vars-editable-ranges"></a>
##### 3.2.2.2 Слайдеры и пределы допустимых значений 

Все переменные с флагом `Editable` должны использовать слайдеры (Slider) и пределы допустимых значений (Value Range), если есть хоть какое-нибудь значение, которое _не должно_ использоваться.

Пример: блупринт, генерирующий забор, может иметь редактируемую переменную `BoardsCount`, и значение -1 не будет являться для него рабочим. Используйте пределы допустимых значений, чтобы обозначить 0 как минимальное значение.

Если редактируемая переменная используется в Construction Script, у неё должен быть настроенный слайдер (Slider Range), который препятствует назначению таких значений, что могут обрушить редактор.

Пределы допустимых значений нужно устанавливать только тогда, когда известны границы этих значений. Если слайдер предотвращает случайный ввод слишком больших значений, то неустановленное значение пределов всё же позволяет указать значения вне диапазона слайдера — "опасные", но всё ещё валидные.

<a name="3.2.3"></a>
<a name="bp-vars-categories"></a>
#### 3.2.3 Категории 

Если у класса совсем немного переменных, то использование категорий не требуется.

Если у класса есть некоторое количество переменных (5-10), все переменные с флагом `Editable` должны обладать своей нестандартной категорией. Для общих переменных создаётся категория `Config`.

Если у класса большое количество переменных, то все переменные с флагом `Editable` должны быть помещены в подкатегории внутри `Config`. Нередактируемые переменные (без флага `Editable`) должны быть помещены в отдельные категории с понятными названиями.

> Вы можете создавать подкатегории, используя символ вертикальной черты `|`, напр. `Config | Animations`.

Пример: набор переменных оружия может быть расположен в следующей иерархии:

    |-- Config
    |   |-- Animations
    |   |-- Effects
    |   |-- Audio
    |   |-- Recoil
    |   |-- Timings
    |-- Animations
    |-- State
    |-- Visuals

<a name="3.2.4"></a>
<a name="bp-vars-access"></a>
#### 3.2.4 Уровень доступа переменных 

В C++ есть реализация уровня доступа переменных. Уровень доступа `Public` означает, что все экземпляры любых классов могут получить доступ к этой переменной. Переменные `Protected` могут использованы только самим классом и дочерними классами. `Private` значит, что только сам класс может видеть эти переменные (дочерние не видят).

В блупринтах, по крайней мере — на данный момент —, нет реализации уровня доступа переменных.

Считайте переменные с флагом `Editable` как публичные. Переменные без этого флага считайте как `Protected`.

<a name="3.2.4.1"></a>
<a name="bp-vars-access-private"></a>
##### 3.2.4.1 Закрытые (`Private`) переменные 

В том случае, если не известно, должна ли быть переменная доступна только в самом классе, но не в дочерних, не отмечайте переменную как `Private`. Используйте `Protected` и закрывайте переменную только тогда, когда вы абсолютно уверены, что хотите ограничить использование переменных в дочерних классах.

<a name="3.2.5"></a>
<a name="bp-vars-advanced"></a>
#### 3.2.5 `Advanced Display` 

Если переменная должна быть редактируема, но, в большинстве случаев, нетронута, отметьте её флагом `Advanced Display`. Переменная будет скрыта, но может быть отображена по клику стрелки в конце категории.

Сам флаг `Advanced Display` тоже является скрытым за этой стрелкой на панеле `Details`.

<a name="3.2.6"></a>
<a name="bp-vars-transient"></a>
#### 3.2.6 `Transient`

Все переменные без флага `Editable` и которые должны обладать нулевым начальным значением, должны быть помечены как `Transient`.

Такие переменные не требуют сохранения и загрузки их значения и изначально равны нулю (zero или null). Они полезны для тех случаев, когда требуется ссылка на других объектов и актёров, не известная до запуска игры.

Этот флаг предотвращает сохранение ссылки на эту переменную внутри редактора и ускоряет процесс сохранения и загрузки класса.

<a name="3.2.7"></a>
<a name="bp-vars-savegame"></a>
#### 3.2.7 Переменные с флагом `SaveGame` 

Используйте флаг `SaveGame` только для переменных класса, унаследованного от класса `SaveGame`. Отмечайте этот флаг, только если `SaveGame` должен сохранить значение. Временные переменные, не хранимые в слоте сохранения, не должны отмечаться этим флагом.

Не смешивайте `SaveGame` и `Transient` — это бесполезно.

<a name="3.2.8"></a>
<a name="bp-vars-config"></a>
#### 3.2.8 Флаг `Config Variable` 

Не используйте флаг `Config Variable`. Дизайнерам будет труднее из-за этого контроллировать поведение блупринта. Этот флаг используется только в C++ для редко меняющихся значений, как если бы они были под двойным флагом `Advanced Display`.

<a name="3.3"></a>
<a name="bp-functions"></a>
### 3.3 Функции, ивенты и ивент диспатчеры.

В этом разделе описывается, как должны функционировать функции, ивенты и ивент диспатчеры. Все, что относится к функциям, относится и к ивентам, если не указано иное.

<a name="3.3.1"></a>
<a name="bp-funcs-naming"></a>
#### 3.3.1 Наименование функций 

Наименование функций, ивентов и ивент диспатчеров очень важно. Исходя только из названия, можно сделать вывод о работе функции. Для примера:
* Это pure функция?
* Это получение информации о каком-либо состоянии?
* Это обработчик события (handler)?
* Это RPC (Remote Procedure Calls)?
* Каково ее назначение?

На эти и другие вопросы могут быть даны ответы, когда функция названа надлежащим образом.

<a name="3.3.1.1"></a>
<a name="bp-funcs-naming-verbs"></a>
#### 3.3.1.1 Названия всех функций должны быть глаголами. 

Все функции и ивенты выполняют те или иные действия, будь то получение информации, вычисление данных или выполнение взрыва. Поэтому все функции должны начинаться с глаголов.
Они должны быть сформулированны в настоящем времени, если это возможно. Они также должны отражать определенный контекст того, что они делают.
`OnRep` функции, обработчики событий (ивентов) и ивент диспатчеры являются исключением из этого правила.

Хорошие примеры:

* `Fire` - Хороший пример, если в Character / Weapon классе, который имеет этот контекст. Плохо если в Barrel / Grass / другом не имеющим этого контекста классе.
* `Jump` -  Хороший пример, если это Character, который имеет этот контекст.
* `Explode`
* `ReceiveMessage`
* `SortPlayerArray`
* `GetArmOffset`
* `GetCoordinates`
* `UpdateTransforms`
* `EnableBigHeadMode`
* `IsEnemy` - ["Is" это глагол.](http://writingexplained.org/is-is-a-verb)

Плохие примеры:

* `Dead` - Is Dead? Will deaden?
* `Rock` - - Существительное неоднозначно.
* `ProcessData` -  Двусмысленно, эти слова ничего не значат.
* `PlayerState` - Существительные неоднозначны.
* `Color` - Глагол без контекста или неоднозначное существительное.

<a name="3.3.1.2"></a>
<a name="bp-funcs-naming-onrep"></a>
#### 3.3.1.2 Свойство RepNotify функций всегда должно иметь обозначение `OnRep_Variable`

Все функции для репликации с переменными уведомлений должны иметь обозначение `OnRep_Variable`. Это принудительно устанавливается редактором блюпринтов. Однако, если вы пишите функцию на С++, которая используется в блюпринтах, то должны указывать это явно.

<a name="3.3.1.3"></a>
<a name="bp-funcs-naming-bool"></a>
#### 3.3.1.3 Название функции, возвращающей bool, должно выражать вопрос.

Когда пишется функция, которая не меняет состояние или не изменяет объект и которая предназначена только для получения информации, состояния, или для вычисления да/нет состояния, то она должна содержать вопрос в названии. Это так же следует правилу [Названия всех функций должны быть глаголами](#bp-funcs-naming-verbs).

Это чрезвычайно важно, так как если вопрос не задан, то можно предположить, что функция выполняет действие и возвращает ответ: было ли это действие успешным.

Хорошие примеры:

* `IsDead`
* `IsOnFire`
* `IsAlive`
* `IsSpeaking`
* `IsHavingAnExistentialCrisis`
* `IsVisible`
* `HasWeapon` - ["Has" это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)
* `WasCharging` - ["Was" это форма прошедшего времени глагола "be".](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html) Используйте "was" когда ссылаетесь на предыдущее состояние.
* `CanReload` - ["Can" это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)

Плохие примеры:

* `Fire` - Горит, стреляет? Будет гореть, стрелять? Поджигает?
* `OnFire` - Можно перепутать с ивент диспатчером для стрельбы.
* `Dead` - Умирает? Умрет?
* `Visibility` - Видимый? Устанавливает видимость? Описание условий видимости?

<a name="3.3.1.4"></a>
<a name="bp-funcs-naming-eventhandlers"></a>
#### 3.3.1.4 Обработчики событий и диспатчеры должны начинаться с `On`.
Любые обработчики событий или диспатчеры должны начинаться с `On` и продолжать следовать [правилу глагола](#bp-funcs-naming-verbs). Глагол может быть перемещен в конец названия, если так лучше в обозначении прошедшего времени.
`Handle` запрещен в названиях.

Хорошие примеры:

* `OnDeath` - Общепринятое словосочетание в разработке игр.
* `OnPickup`
* `OnReceiveMessage`
* `OnMessageRecieved`
* `OnTargetChanged`
* `OnClick`
* `OnLeave`

Плохие примеры:

* `OnData`
* `OnTarget`
* `HandleMessage`
* `HandleDeath`

<a name="3.3.1.5"></a>
<a name="bp-funcs-naming-rpcs"></a>
#### 3.3.1.5 RPC должны быть с префиксом цели вызова.

Префикс может быть одним из: `Server`, `Client`, or `Multicast`, без исключений.

После префикса название должно следовать остальным правилам наименований.

Хорошие примеры:

* `ServerFireWeapon`
* `ClientNotifyDeath`
* `MulticastSpawnTracerEffect`

Плохие примеры:

* `FireWeapon` - Не обозначается как функция рода RPC.
* `ServerClientBroadcast` - Сбивает с толку.
* `AllNotifyDeath` - Используйте `Multicast`, никогда `All`.
* `ClientWeapon` - Нет глаголов, двусмысленно.


<a name="3.3.2"></a>
<a name="bp-funcs-return"></a>
#### 3.3.2 Все выходы функции должны иметь ноду Return.

Ноды Return явно указывают, что функция завершила выполнение. В мире, где блюпринты могут быть сделаны с `Sequence`, `ForLoopWithBreak` и перенаправлений в обратную сторону, явный поток выполнения важен для читаемости, поддержки и простой отладки.

Компилятор блюпринтов способен следить за потоком выполнения и предупредит, есть ли ветка кода с необработанным возвратом функции или плохим потоком, если вы используете ноды Return

В ситуации, когда программист может добавить пин в Sequence или добавить логику после окончания цикла, но итерация цикла может завершиться раньше чем нужно, это часто может привести к случайной ошибке в потоке блюпринтов. Варнинги компилятора блюпринтов немедленно предупредят вас об этом.

<a name="3.3.3"></a>
<a name="bp-graphs-funcs-node-limit"></a>
#### 3.3.3 Не должно быть функций с более чем 50 нодами.

Любая функция такого размера должна быть разбита на более мелкие функции для удобства чтения и поддержки.

Следующие ноды не учитываются, так как считается, что они не увеличивают сложность функций:

* Comment
* Route
* Cast
* Getting a Variable
* Breaking a Struct
* Function Entry
* Self

<a name="3.3.4"></a>
<a name="bp-graphs-funcs-description"></a>
#### 3.3.4 Все функции должны иметь осмысленное описание в поле `Description` 

Если описание очень большое, то допускается разместить его в комментариях внутри функции, а в поле `Description` дать краткое описание.

<a name="3.3.5"></a>
<a name="bp-graphs-funcs-plugin-category"></a>
#### 3.3.5 Все статические плагиновые `BlueprintCallable` функции должны быть в категории `Plugin Name`

Если ваш проект включает плагин, в котором есть статические `BlueprintCallable` функции, то они должны иметь соответствующую своему плагину категорию.

Для примера, `Zed Camera Interface` или `Zed Camera Interface | Image Capturing`.

<a name="3.3.6"></a>
#### 3.3.6 Функция или ивент должны быть разработаны и вызваны наиболее эффективно. Нет смысла рассчитывать одно и то же значение несколько раз.

* Если функция вызывается в другой функции (или ивенте) несколько раз, чтобы получить какое-то значение, то записывайте это значение в локальную переменную. Используйте эту локальную переменную, а не дополнительный вызов функции.
* Не вызывайте функции в цикле, если они выдают одно и то же значение. Вызывайте такие функции до цикла и записывайте возвращаемое значение в локальную переменную.
* Если функции содержат другие функции, которые возвращают какое-то значение, то проектируйте их так, чтобы не было лишних вызовов.

<a name="3.3.7"></a>
#### 3.3.7 Не делайте функции, которые возвращают более одного значения. 
Да, блюпринты позволяют это. Но такие функции не переносимы на С++. Кроме того, это запутывает логику. Есть два хороших варианта:
* Разделите логику на две функции, каждая из которых будет возвращать по одному значению.
* Создайте структуру с имененем `SFunctionNameOutput` и сделайте ее возвращаемым значением вашей функции.

<a name="3.3.8"></a>
#### 3.3.8 Если выбирать между ивентом и функцией, то выбирайте функцию, если это возможно.
Ивенты располагаются в одном графе и граф выглядит как одна большая функция. Если в графе много ивентов, то становится трудно найти нужную логику, даже если блоки прокомментированы. Не злоупотребляйте ивентами.

<a name="3.3.8"></a>
#### 3.3.8 Не используйте следующие конструкции, если их можно заменить функциями:
* Все макросы. Они избыточны. Некоторые их них трудно переносить на С++. Включая такие макросы как Gate, Multigate, DoN, DoOnce и пр. Кроме, конечно, циклов for, while. 
* Субграфы (Subgraphs). Они избыточны.
* Delay. Она не переносима на С++ и вызывает проблемы при нативизации. Используйте SetTimerByFunctionName или SetTimerByEvent.
* Select. Чтобы перенести логику на этой ноде на С++, иногда нужно во многом изменить ее.  
* EventTick. Используйте SetTimerByFunctionName или SetTimerByEvent..

<a name="3.3.9"></a>
#### 3.3.9 Если вы знаете С++, то делайте блюпринты так, чтобы логика без изменения и легко переносилась на С++.
Это сэкономит время, когда потребуется перенести блюпринты на С++.

<a name="3.4"></a>
<a name="bp-graphs"></a>
### 3.4 Графы блюпринтов (Blueprint Graphs). 

<a name="3.4.1"></a>
<a name="bp-graphs-spaghetti"></a>
#### 3.4.1 Никаких спагетти.

* Соединения должны иметь четкие начала и концы. Вы не должны мысленно распутывать проводки, чтобы выяснить смысл графа. 
* Соединения не должны пересекаться между собой, если это возможно.
* Соединения должны идти прямо либо однонаправленно, если это возможно.
* Соединения не должны быть слишком длинные, держите их в пределах вашего монитора. Чтобы избежать слишком длинных соединений, используйте локальные переменные в функциях. 
* Соединений должно быть минимальное количество. Чтобы уменьшить количество соединений, скопируйте или вытяните дополнительный геттер (нода `Get Value`) вместо дополнительного соединения.

<a name="3.4.2"></a>
<a name="bp-graphs-align-wires"></a>
#### 3.4.2 Выравнивайте связи, а не ноды. 

Всегда выравнивайте связи, а не ноды. Вы не всегда можете контролировать размер ноды и положение пина в ней, но вы всегда можете контролировать положение ноды и таким образом управлять связями. Прямые связи выглядят как чистый линейный поток. Вы можете выравнивать связи автоматически командой Straighten Connections над выделенными нодами. Горячая клавиша: Q.

<a name="3.4.3"></a>
<a name="bp-graphs-exec-first-class"></a>
#### 3.4.3 Белые связи в приоритете выравнивания.

Если выбирать между выравниванием белых (Exec) и цветных (Data) связей, то выравнивайте белые связи.

<a name="3.4.4"></a>
<a name="bp-graphs-block-comments"></a>
#### 3.4.4 Осмысленно комментируйте графы.

Блоки нод следует обволакивать в комментарии, которые отражают их поведение. Как и каждая функция должна быть хорошо названа, чтобы каждый отдельный логический блок был легко читаемым и понятным, так и группы блоков, составляющих логику, должны быть осмысленно прокомментированы.
Если функция содержит не много блоков нод и ясно, что блоки служат прямой цели функции, то не нужно их комментировать, так как имени и описания функции должно хватить.

<a name="3.4.5"></a>
<a name="bp-graphs-cast-error-handling"></a>
#### 3.4.5 Графы должны обрабатывать ошибки приведения типов (Cast, касты), где это уместно. 

Если работа функции или ивента предполагает, что приведение должно выполниться успешно, то она должна сообщать об ошибке в логике, если приведение не удастся. Это дает знать, почему не работает то, что должно работать. Функция также должна обрабатывать ошибки приведения, то есть предпринять какие-то меры по восстановлению работы, если это важно.
Это не значит, что нужно обрабатывать каждую ошибку каста. Во многих случаях (например, при обработке коллизий) ожидается, что поток выполнения завершится при неудачном касте.

<a name="3.4.6"></a>
<a name="bp-graphs-dangling-nodes"></a>
#### 3.4.6 На графах не должно быть ненужных (оборванных) связей, узлов, нод.
Все ноды и связи должны присутствовать в графе, только если они используются и включены в работу. Вы не должны оставлять на графе связи, которые не идут к нодам, или ноды, если они не выполняются.

**[⬆ Back to Top](#bp)**
